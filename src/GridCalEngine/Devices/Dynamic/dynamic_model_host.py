# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.
# SPDX-License-Identifier: MPL-2.0
from typing import List, Dict, Any
from GridCalEngine.Devices.Dynamic.dynamic_model import DynamicModel


class DynamicModelHost:
    """
    This class serves to give flexible access to either a template or a custom model
    """
    def __init__(self):

        self._template: DynamicModel | None = None

        # a custom model always exits although it may be empty
        self._custom_model: DynamicModel = DynamicModel()

    @property
    def template(self):
        return self._template

    @template.setter
    def template(self, val: DynamicModel):
        self._template = val

    @property
    def custom_model(self):
        return self._custom_model

    @property
    def model(self) -> DynamicModel:
        """
        Returns whatever is available with preference to the custom model if any
        :return: DynamicModel (even if it is empty)
        """
        if self.template is None:
            return self.custom_model
        else:
            return self.template

    def to_dict(self) -> Dict[str, str | Dict[str, List[Dict[str, Any]]]]:
        """
        Generate a dictionary to save
        :return:
        """
        return {
            "template": self.template.idtag if self.template is not None else None,
            "custom_model": self.custom_model.to_dict()
        }

    def parse(self, data: Dict[str, str | Dict[str, List[Dict[str, Any]]]],
              models_dict: Dict[str, DynamicModel]):
        """
        Parse the data
        :param data: data generated by to_dict
        :param models_dict: dictionary of DynamicModel to find the template reference
        :return:
        """
        template_id = data.get("template", None)
        if template_id is not None:
            self.template = models_dict.get(template_id, None)

        custom_data = data.get("custom_model", None)
        self.custom_model.parse(data=custom_data)


